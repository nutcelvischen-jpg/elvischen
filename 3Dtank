<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 坦克戰場 - 重裝甲版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* 背景改為深灰藍色，配合城市戰氛圍 */
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #2c3e50; color: #ecf0f1; user-select: none; }
        canvas { display: block; outline: none; }
        
        /* UI 樣式 */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: center;
            padding-top: 20px;
        }

        .panel {
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            padding: 15px 30px;
            border-radius: 4px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            pointer-events: auto;
            transform: skew(-10deg);
        }
        
        .panel > * { transform: skew(10deg); } 

        .title {
            font-size: 1.8rem;
            color: #76b852; /* 迷彩綠標題 */
            font-weight: 800;
            letter-spacing: 3px;
            text-shadow: none;
            margin-bottom: 5px;
        }

        .stats-row {
            display: flex;
            gap: 40px;
            font-size: 1.2rem;
            font-weight: bold;
            margin-top: 10px;
            color: #bdc3c7;
        }

        .stat-item { display: flex; align-items: center; gap: 10px; }
        .stat-label { color: #7f8c8d; font-size: 0.9rem; text-transform: uppercase; }
        .hp-val { color: #e74c3c; font-size: 1.5rem; font-family: monospace; }
        .enemy-val { color: #f39c12; font-size: 1.5rem; font-family: monospace; }

        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            font-weight: bold;
            text-align: left;
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid #76b852;
        }

        #game-over-screen {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 20, 20, 0.9);
            z-index: 100;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            pointer-events: auto;
        }

        .end-title { font-size: 4rem; font-weight: 900; margin-bottom: 20px; letter-spacing: 5px; }
        .victory { color: #76b852; text-shadow: 0 4px 10px rgba(118, 184, 82, 0.3); }
        .defeat { color: #e74c3c; text-shadow: 0 4px 10px rgba(231, 76, 60, 0.3); }

        .btn-restart {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: #556b2f;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.2s;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .btn-restart:hover { background: #6b8e23; transform: translateY(-2px); }

    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div class="ui-layer">
        <div class="hud-top">
            <div class="panel">
                <div class="title">URBAN WARFARE</div>
                <div class="stats-row">
                    <div class="stat-item">
                        <span class="stat-label">Armor</span>
                        <span id="hp-val" class="hp-val">100%</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Hostiles</span>
                        <span id="enemy-val" class="enemy-val">0</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="controls-hint">
            [W] 前進 (Forward)<br>
            [S] 後退 (Backward)<br>
            [A/D] 左右轉向<br>
            [MOUSE] 瞄準 [L-CLICK] 開火
        </div>
    </div>

    <div id="game-over-screen">
        <h1 id="end-title" class="end-title">MISSION COMPLETE</h1>
        <button class="btn-restart" onclick="location.reload()">Reboot System</button>
    </div>

    <script>
        // ------------------------------------------------------------------
        // CONFIGURATION
        // ------------------------------------------------------------------
        const CONFIG = {
            mapSize: 100,
            wallHeight: 6, // 牆壁稍微加高，更有城市感
            
            // 物理手感參數
            playerMaxSpeed: 0.6,
            playerAcceleration: 0.04,
            playerFriction: 0.88,
            playerTurnSpeed: 0.04,
            
            enemyMaxSpeed: 0.25,
            enemyTurnSpeed: 0.03,
            
            bulletSpeed: 2.0,
            fireRate: 500, // ms
            playerMaxHP: 40, // [修改] 裝甲升級：玩家現在有 40 滴血
            enemyMaxHP: 3,
            
            cameraHeight: 40, // 相機稍微拉高一點，看清楚街道
            cameraDistance: 28
        };

        // 全域變數
        let scene, camera, renderer;
        let playerTank;
        let enemies = [];
        let bullets = [];
        let walls = []; 
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let isGameOver = false;
        let mapBounds = CONFIG.mapSize / 2;

        // ------------------------------------------------------------------
        // Core Classes
        // ------------------------------------------------------------------
        
        class Tank {
            constructor(x, z, color, isPlayer = false) {
                this.isPlayer = isPlayer;
                this.hp = isPlayer ? CONFIG.playerMaxHP : CONFIG.enemyMaxHP;
                
                // 物理屬性
                this.velocity = 0;
                this.maxSpeed = isPlayer ? CONFIG.playerMaxSpeed : CONFIG.enemyMaxSpeed;
                this.acceleration = isPlayer ? CONFIG.playerAcceleration : 0.02;
                this.friction = isPlayer ? CONFIG.playerFriction : 0.9;
                
                this.mesh = new THREE.Group();
                this.lastFireTime = 0;
                this.isDead = false;
                this.baseColor = color; // 記住原始顏色
                this.radius = 2.8;

                this.createModel(color);
                this.mesh.position.set(x, 0, z);
                scene.add(this.mesh);
            }

            createModel(color) {
                const matBody = new THREE.MeshPhongMaterial({ color: color, flatShading: true });
                const matTrack = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const matDark = new THREE.MeshLambertMaterial({ color: 0x222222 });

                // 車體中心
                const chassis = new THREE.Mesh(new THREE.BoxGeometry(3.8, 1.5, 5.5), matBody);
                chassis.position.y = 0.9;
                chassis.castShadow = true;
                chassis.receiveShadow = true;
                this.mesh.add(chassis);

                // 履帶 (深黑色)
                const trackGeo = new THREE.BoxGeometry(1, 1.4, 6);
                const leftTrack = new THREE.Mesh(trackGeo, matTrack);
                leftTrack.position.set(-2.2, 0.7, 0);
                leftTrack.castShadow = true;
                this.mesh.add(leftTrack);

                const rightTrack = new THREE.Mesh(trackGeo, matTrack);
                rightTrack.position.set(2.2, 0.7, 0);
                rightTrack.castShadow = true;
                this.mesh.add(rightTrack);

                // 砲塔 Group
                this.turret = new THREE.Group();
                this.turret.position.set(0, 1.65, 0);
                this.mesh.add(this.turret);

                // 砲塔頭
                const turretHead = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.2, 3.5), matBody);
                turretHead.position.y = 0.6;
                turretHead.castShadow = true;
                this.turret.add(turretHead);

                // 砲管
                const cannon = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 5, 12), matDark);
                cannon.rotation.x = Math.PI / 2;
                cannon.position.set(0, 0.6, 2.5); 
                cannon.castShadow = true;
                this.turret.add(cannon);
                this.cannonMesh = cannon; 
            }

            updatePhysics(inputMove, inputRotate) {
                if (this.isDead) return;

                // 1. 旋轉
                const turnSpeed = this.isPlayer ? CONFIG.playerTurnSpeed : CONFIG.enemyTurnSpeed;
                this.mesh.rotation.y += inputRotate * turnSpeed;

                // 2. 速度計算
                if (inputMove !== 0) {
                    this.velocity += inputMove * this.acceleration;
                }
                this.velocity = Math.max(Math.min(this.velocity, this.maxSpeed), -this.maxSpeed);
                this.velocity *= this.friction;

                if (Math.abs(this.velocity) < 0.001) this.velocity = 0;

                // 3. 計算位移
                if (this.velocity !== 0) {
                    const direction = new THREE.Vector3(0, 0, 1);
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.mesh.rotation.y);
                    
                    const moveStep = direction.multiplyScalar(this.velocity);
                    const newPos = this.mesh.position.clone().add(moveStep);
                    
                    if (!this.checkCollision(newPos)) {
                        this.mesh.position.copy(newPos);
                    } else {
                        this.velocity *= -0.5;
                    }
                }

                // 後座力復原
                if (this.cannonMesh.position.z > 2.5) {
                    this.cannonMesh.position.z -= 0.1;
                }
            }

            checkCollision(pos) {
                const limit = mapBounds - 2;
                if (pos.x < -limit || pos.x > limit || pos.z < -limit || pos.z > limit) return true;

                const tankBox = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(3, 4, 3));
                
                for (let wall of walls) {
                    if (tankBox.intersectsBox(wall.box)) {
                        return true;
                    }
                }
                
                if (this.isPlayer) {
                    for(let e of enemies) {
                        if (!e.isDead && pos.distanceTo(e.mesh.position) < 5) return true;
                    }
                } else {
                    if (!playerTank.isDead && pos.distanceTo(playerTank.mesh.position) < 5) return true;
                }

                return false;
            }

            aimAt(targetPos) {
                if (this.isDead) return;
                
                const dx = targetPos.x - this.mesh.position.x;
                const dz = targetPos.z - this.mesh.position.z;
                let targetAngle = Math.atan2(dx, dz);
                let localTargetRotation = targetAngle - this.mesh.rotation.y;
                
                while (localTargetRotation > Math.PI) localTargetRotation -= Math.PI * 2;
                while (localTargetRotation < -Math.PI) localTargetRotation += Math.PI * 2;

                this.turret.rotation.y += (localTargetRotation - this.turret.rotation.y) * 0.15;
            }

            shoot() {
                if (this.isDead) return;
                const now = performance.now();
                if (now - this.lastFireTime > CONFIG.fireRate) {
                    createBullet(this);
                    this.lastFireTime = now;
                    this.cannonMesh.position.z = 1.8;
                }
            }

            takeDamage() {
                this.hp--;
                
                // ---------------------------------------------------------
                // 視覺效果：中彈時從「深色」變「淺色」 (Deep to Light)
                // ---------------------------------------------------------
                const hitColor = 0xddeedd; // 接近白色的極淺綠
                
                this.mesh.traverse(c => {
                    if (c.isMesh && c.material.name !== 'track') { // 不改變履帶顏色
                        // 暫時變成淺色
                        c.material.color.setHex(hitColor);
                        // 增加發光感 (emissive)
                        c.material.emissive.setHex(0x555555);
                    }
                });

                setTimeout(() => {
                    if(!this.isDead) {
                        this.mesh.traverse(c => {
                            if (c.isMesh && c.material.name !== 'track') {
                                // 恢復原本的深色
                                c.material.color.setHex(this.baseColor);
                                c.material.emissive.setHex(0x000000);
                            }
                        });
                    }
                }, 100); // 閃爍時間

                if (this.isPlayer) {
                    // 更新血量顯示，確保比例正確
                    document.getElementById('hp-val').innerText = Math.max(0, Math.ceil(this.hp / CONFIG.playerMaxHP * 100)) + "%";
                }

                if (this.hp <= 0) this.die();
            }

            die() {
                this.isDead = true;
                scene.remove(this.mesh);
                createExplosion(this.mesh.position);

                if (this.isPlayer) {
                    endGame(false);
                } else {
                    enemies = enemies.filter(e => e !== this);
                    document.getElementById('enemy-val').innerText = enemies.length;
                    if (enemies.length === 0) endGame(true);
                }
            }
        }

        // ------------------------------------------------------------------
        // Game Logic
        // ------------------------------------------------------------------

        function init() {
            const container = document.getElementById('game-container');
            
            // 場景設置 - 城市灰暗色調
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50); // 城市夜空/陰天藍
            scene.fog = new THREE.FogExp2(0x2c3e50, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 燈光系統 - 對比度強烈一點
            const ambient = new THREE.HemisphereLight(0x999999, 0x444444, 0.6);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1.0);
            sun.position.set(50, 80, 40);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            createLevel();

            // 玩家 - 迷彩色 (深軍綠)
            // 顏色代碼: 0x4b5320 (Army Green) 或 0x556b2f (Dark Olive Green)
            playerTank = new Tank(0, 30, 0x556b2f, true); 
            playerTank.mesh.rotation.y = Math.PI; 

            // 敵人 - 暗紅色
            spawnEnemies(4);

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            document.addEventListener('mousedown', (e) => {
                if (!isGameOver && e.button === 0) playerTank.shoot();
            });

            animate();
        }

        function createLevel() {
            // 地板 - 水泥灰
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.9 }); // 灰色水泥地
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // 網格線改為淡淡的白色，像停車場標線
            const grid = new THREE.GridHelper(200, 50, 0x95a5a6, 0x95a5a6);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            // 地圖佈局 - 建築物牆壁
            const w = CONFIG.wallHeight;
            const wallGeo = new THREE.BoxGeometry(10, w, 10);
            // 牆壁顏色：深水泥灰
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5 });

            const positions = [
                [20, 20], [20, 30], [30, 20],
                [-20, 20], [-20, 30], [-30, 20],
                [20, -20], [20, -30], [30, -20],
                [-20, -20], [-20, -30], [-30, -20],
                [10, 0], [-10, 0], [0, 10], [0, -10]
            ];

            positions.forEach(pos => {
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set(pos[0], w/2, pos[1]);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                
                wall.box = new THREE.Box3().setFromObject(wall);
                walls.push({ mesh: wall, box: wall.box });
            });
            
            // 邊界框 (深色邊界)
            const borderMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.2 });
            const borderBox = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.mapSize, 10, CONFIG.mapSize), borderMat);
            borderBox.position.y = 5;
            scene.add(borderBox);
        }

        function spawnEnemies(count) {
            const spawnPoints = [
                {x: -40, z: -40}, {x: 40, z: -40},
                {x: -40, z: 40}, {x: 40, z: 40}
            ];

            for (let i = 0; i < count; i++) {
                const pos = spawnPoints[i % spawnPoints.length];
                // 敵人使用深紅色，增加對比
                const enemy = new Tank(pos.x, pos.z, 0x8b0000); 
                enemies.push(enemy);
            }
            document.getElementById('enemy-val').innerText = enemies.length;
        }

        function createBullet(ownerTank) {
            const geo = new THREE.SphereGeometry(0.35, 8, 8);
            // 子彈改為亮橘色，在深色背景更明顯
            const mat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            const bullet = new THREE.Mesh(geo, mat);

            const muzzleOffset = new THREE.Vector3(0, 0.6, 5);
            muzzleOffset.applyMatrix4(ownerTank.turret.matrixWorld);
            
            bullet.position.copy(muzzleOffset);

            const direction = new THREE.Vector3(0, 0, 1);
            direction.applyQuaternion(ownerTank.turret.getWorldQuaternion(new THREE.Quaternion()));

            bullet.velocity = direction.multiplyScalar(CONFIG.bulletSpeed);
            bullet.owner = ownerTank;
            bullet.life = 120;

            scene.add(bullet);
            bullets.push(bullet);
        }

        function createExplosion(pos) {
            const geo = new THREE.DodecahedronGeometry(2);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff4400, wireframe: true });
            const exp = new THREE.Mesh(geo, mat);
            exp.position.copy(pos);
            scene.add(exp);
            
            let scale = 1;
            const anim = setInterval(() => {
                scale += 0.2;
                exp.scale.setScalar(scale);
                exp.rotation.x += 0.1;
                exp.rotation.y += 0.1;
                exp.material.opacity -= 0.1;
                if(scale > 3) {
                    clearInterval(anim);
                    scene.remove(exp);
                }
            }, 30);
        }

        // ------------------------------------------------------------------
        // Update Loop
        // ------------------------------------------------------------------

        function updatePlayer() {
            if (playerTank.isDead) return;

            let moveInput = 0;
            let rotateInput = 0;

            if (keys['w']) moveInput = 1;
            if (keys['s']) moveInput = -1;
            if (keys['a']) rotateInput = 1;
            if (keys['d']) rotateInput = -1;

            playerTank.updatePhysics(moveInput, rotateInput);

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (mouseX / window.innerWidth) * 2 - 1,
                -(mouseY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            if (target) playerTank.aimAt(target);

            const idealOffset = new THREE.Vector3(0, CONFIG.cameraHeight, CONFIG.cameraDistance);
            const idealPos = playerTank.mesh.position.clone().add(idealOffset);
            camera.position.lerp(idealPos, 0.1); 
            camera.lookAt(playerTank.mesh.position);
        }

        function updateEnemies() {
            if (playerTank.isDead) return;

            enemies.forEach(enemy => {
                if (enemy.isDead) return;

                const diff = new THREE.Vector3().subVectors(playerTank.mesh.position, enemy.mesh.position);
                const dist = diff.length();

                let moveInput = 0;
                let rotateInput = 0;

                const targetAngle = Math.atan2(diff.x, diff.z);
                let angleDiff = targetAngle - enemy.mesh.rotation.y;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                if (Math.abs(angleDiff) > 0.1) {
                    rotateInput = angleDiff > 0 ? 1 : -1;
                }

                if (Math.abs(angleDiff) < 0.5) {
                    if (dist > 15) moveInput = 1;
                    else if (dist < 8) moveInput = -0.5;
                }

                enemy.aimAt(playerTank.mesh.position);
                
                if (dist < 40 && Math.abs(angleDiff) < 0.3) {
                    enemy.shoot();
                }

                enemy.updatePhysics(moveInput, rotateInput);
            });
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                const prevPos = b.position.clone();
                b.position.add(b.velocity);
                b.life--;

                let hit = false;

                if (Math.abs(b.position.x) > 60 || Math.abs(b.position.z) > 60) hit = true;

                if (!hit) {
                    for (let wall of walls) {
                        if (wall.box.containsPoint(b.position)) {
                            hit = true; break;
                        }
                    }
                }

                if (!hit) {
                    const checkList = [playerTank, ...enemies];
                    for (let tank of checkList) {
                        if (tank === b.owner || tank.isDead) continue;
                        if (b.position.distanceTo(tank.mesh.position) < tank.radius) {
                            tank.takeDamage();
                            hit = true;
                            break;
                        }
                    }
                }

                if (hit || b.life <= 0) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }
        }

        function endGame(victory) {
            isGameOver = true;
            const screen = document.getElementById('game-over-screen');
            const title = document.getElementById('end-title');
            screen.style.display = 'flex';
            
            if (victory) {
                title.innerText = "TARGETS ELIMINATED";
                title.className = "end-title victory";
            } else {
                title.innerText = "CRITICAL FAILURE";
                title.className = "end-title defeat";
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isGameOver) {
                updatePlayer();
                updateEnemies();
                updateBullets();
            }

            renderer.render(scene, camera);
        }

        window.onload = init;

    </script>
</body>
</html>
